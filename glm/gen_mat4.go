// Code generated by generate.go: DO NOT EDIT.

package glm

// Mat4f is an alias for the float32 variant of Mat4
type Mat4f = Mat4[float32]

// Mat4u is an alias for the uint32 variant of Mat4
type Mat4u = Mat4[uint32]

// Mat4uh is an alias for the uint16 variant of Mat4
type Mat4uh = Mat4[uint16]

// Mat4 is a 4x4 matrix.
// The default value is the identity matrix.
type Mat4[T Numeric] struct {
	values [4][4]T
}

func Mat4Of[T Numeric](values [4][4]T) Mat4[T] {
	return Mat4[T]{
		values: [4][4]T{
			{
				values[0][0] - 1,
				values[0][1],
				values[0][2],
				values[0][3],
			},
			{
				values[1][0],
				values[1][1] - 1,
				values[1][2],
				values[1][3],
			},
			{
				values[2][0],
				values[2][1],
				values[2][2] - 1,
				values[2][3],
			},
			{
				values[3][0],
				values[3][1],
				values[3][2],
				values[3][3] - 1,
			},
		},
	}
}

func IdentityMat4[T Numeric]() Mat4[T] {
	return Mat4[T]{}
}

func (m Mat4[T]) Mul(o Mat4[T]) Mat4[T] {
	mv := &m.values
	ov := &o.values

	return Mat4[T]{
		values: [4][4]T{
			{
				(mv[0][0]+1)*(ov[0][0]+1) + (mv[1][0]+0)*(ov[0][1]+0) + (mv[2][0]+0)*(ov[0][2]+0) + (mv[3][0]+0)*(ov[0][3]+0) - 1,
				(mv[0][1]+0)*(ov[0][0]+1) + (mv[1][1]+1)*(ov[0][1]+0) + (mv[2][1]+0)*(ov[0][2]+0) + (mv[3][1]+0)*(ov[0][3]+0),
				(mv[0][2]+0)*(ov[0][0]+1) + (mv[1][2]+0)*(ov[0][1]+0) + (mv[2][2]+1)*(ov[0][2]+0) + (mv[3][2]+0)*(ov[0][3]+0),
				(mv[0][3]+0)*(ov[0][0]+1) + (mv[1][3]+0)*(ov[0][1]+0) + (mv[2][3]+0)*(ov[0][2]+0) + (mv[3][3]+1)*(ov[0][3]+0),
			},
			{
				(mv[0][0]+1)*(ov[1][0]+0) + (mv[1][0]+0)*(ov[1][1]+1) + (mv[2][0]+0)*(ov[1][2]+0) + (mv[3][0]+0)*(ov[1][3]+0),
				(mv[0][1]+0)*(ov[1][0]+0) + (mv[1][1]+1)*(ov[1][1]+1) + (mv[2][1]+0)*(ov[1][2]+0) + (mv[3][1]+0)*(ov[1][3]+0) - 1,
				(mv[0][2]+0)*(ov[1][0]+0) + (mv[1][2]+0)*(ov[1][1]+1) + (mv[2][2]+1)*(ov[1][2]+0) + (mv[3][2]+0)*(ov[1][3]+0),
				(mv[0][3]+0)*(ov[1][0]+0) + (mv[1][3]+0)*(ov[1][1]+1) + (mv[2][3]+0)*(ov[1][2]+0) + (mv[3][3]+1)*(ov[1][3]+0),
			},
			{
				(mv[0][0]+1)*(ov[2][0]+0) + (mv[1][0]+0)*(ov[2][1]+0) + (mv[2][0]+0)*(ov[2][2]+1) + (mv[3][0]+0)*(ov[2][3]+0),
				(mv[0][1]+0)*(ov[2][0]+0) + (mv[1][1]+1)*(ov[2][1]+0) + (mv[2][1]+0)*(ov[2][2]+1) + (mv[3][1]+0)*(ov[2][3]+0),
				(mv[0][2]+0)*(ov[2][0]+0) + (mv[1][2]+0)*(ov[2][1]+0) + (mv[2][2]+1)*(ov[2][2]+1) + (mv[3][2]+0)*(ov[2][3]+0) - 1,
				(mv[0][3]+0)*(ov[2][0]+0) + (mv[1][3]+0)*(ov[2][1]+0) + (mv[2][3]+0)*(ov[2][2]+1) + (mv[3][3]+1)*(ov[2][3]+0),
			},
			{
				(mv[0][0]+1)*(ov[3][0]+0) + (mv[1][0]+0)*(ov[3][1]+0) + (mv[2][0]+0)*(ov[3][2]+0) + (mv[3][0]+0)*(ov[3][3]+1),
				(mv[0][1]+0)*(ov[3][0]+0) + (mv[1][1]+1)*(ov[3][1]+0) + (mv[2][1]+0)*(ov[3][2]+0) + (mv[3][1]+0)*(ov[3][3]+1),
				(mv[0][2]+0)*(ov[3][0]+0) + (mv[1][2]+0)*(ov[3][1]+0) + (mv[2][2]+1)*(ov[3][2]+0) + (mv[3][2]+0)*(ov[3][3]+1),
				(mv[0][3]+0)*(ov[3][0]+0) + (mv[1][3]+0)*(ov[3][1]+0) + (mv[2][3]+0)*(ov[3][2]+0) + (mv[3][3]+1)*(ov[3][3]+1) - 1,
			},
		},
	}
}

func (m Mat4[T]) Transpose() Mat4[T] {
	mv := &m.values

	return Mat4[T]{
		values: [4][4]T{
			{
				mv[0][0],
				mv[1][0],
				mv[2][0],
				mv[3][0],
			},
			{
				mv[0][1],
				mv[1][1],
				mv[2][1],
				mv[3][1],
			},
			{
				mv[0][2],
				mv[1][2],
				mv[2][2],
				mv[3][2],
			},
			{
				mv[0][3],
				mv[1][3],
				mv[2][3],
				mv[3][3],
			},
		},
	}
}

func (m Mat4[T]) Values() [4][4]T {
	values := m.values
	values[0][0] += 1
	values[1][1] += 1
	values[2][2] += 1
	values[3][3] += 1
	return values
}

func (m Mat4[T]) m00() T {
	return (m.values[0][0] + 1)
}

func (m Mat4[T]) m01() T {
	return (m.values[0][1] + 0)
}

func (m Mat4[T]) m02() T {
	return (m.values[0][2] + 0)
}

func (m Mat4[T]) m03() T {
	return (m.values[0][3] + 0)
}

func (m Mat4[T]) m10() T {
	return (m.values[1][0] + 0)
}

func (m Mat4[T]) m11() T {
	return (m.values[1][1] + 1)
}

func (m Mat4[T]) m12() T {
	return (m.values[1][2] + 0)
}

func (m Mat4[T]) m13() T {
	return (m.values[1][3] + 0)
}

func (m Mat4[T]) m20() T {
	return (m.values[2][0] + 0)
}

func (m Mat4[T]) m21() T {
	return (m.values[2][1] + 0)
}

func (m Mat4[T]) m22() T {
	return (m.values[2][2] + 1)
}

func (m Mat4[T]) m23() T {
	return (m.values[2][3] + 0)
}

func (m Mat4[T]) m30() T {
	return (m.values[3][0] + 0)
}

func (m Mat4[T]) m31() T {
	return (m.values[3][1] + 0)
}

func (m Mat4[T]) m32() T {
	return (m.values[3][2] + 0)
}

func (m Mat4[T]) m33() T {
	return (m.values[3][3] + 1)
}
