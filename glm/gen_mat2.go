// Code generated by generate.go: DO NOT EDIT.

package glm

// Mat2f is an alias for the float32 variant of Mat2
type Mat2f = Mat2[float32]

// Mat2u is an alias for the uint32 variant of Mat2
type Mat2u = Mat2[uint32]

// Mat2uh is an alias for the uint16 variant of Mat2
type Mat2uh = Mat2[uint16]

// Mat2 is a 2x2 matrix.
// The default value is the identity matrix.
type Mat2[T Numeric] struct {
	values [2][2]T
}

func Mat2Of[T Numeric](values [2][2]T) Mat2[T] {
	return Mat2[T]{
		values: [2][2]T{
			{
				values[0][0] - 1,
				values[0][1],
			},
			{
				values[1][0],
				values[1][1] - 1,
			},
		},
	}
}

func IdentityMat2[T Numeric]() Mat2[T] {
	return Mat2[T]{}
}

func (m Mat2[T]) Mul(o Mat2[T]) Mat2[T] {
	mv := &m.values
	ov := &o.values

	return Mat2[T]{
		values: [2][2]T{
			{
				(mv[0][0]+1)*(ov[0][0]+1) + (mv[1][0]+0)*(ov[0][1]+0) - 1,
				(mv[0][1]+0)*(ov[0][0]+1) + (mv[1][1]+1)*(ov[0][1]+0),
			},
			{
				(mv[0][0]+1)*(ov[1][0]+0) + (mv[1][0]+0)*(ov[1][1]+1),
				(mv[0][1]+0)*(ov[1][0]+0) + (mv[1][1]+1)*(ov[1][1]+1) - 1,
			},
		},
	}
}

func (m Mat2[T]) Transpose() Mat2[T] {
	mv := &m.values

	return Mat2[T]{
		values: [2][2]T{
			{
				mv[0][0],
				mv[1][0],
			},
			{
				mv[0][1],
				mv[1][1],
			},
		},
	}
}

func (m Mat2[T]) Values() [2][2]T {
	values := m.values
	values[0][0] += 1
	values[1][1] += 1
	return values
}

func (m Mat2[T]) m00() T {
	return (m.values[0][0] + 1)
}

func (m Mat2[T]) m01() T {
	return (m.values[0][1] + 0)
}

func (m Mat2[T]) m10() T {
	return (m.values[1][0] + 0)
}

func (m Mat2[T]) m11() T {
	return (m.values[1][1] + 1)
}
