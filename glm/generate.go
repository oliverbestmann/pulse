//go:build generate

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"text/template"
)

//go:generate go run generate.go

func main() {
	generateVecs()
	generateMats()
}

func generateVecs() {
	vecTypes := []modelVec{
		{
			Len:     2,
			LenWGPU: 2,
		},
		{
			Len:     3,
			LenWGPU: 4,
		},
		{
			Len:     4,
			LenWGPU: 4,
		},
	}

	for _, vecType := range vecTypes {
		var buf bytes.Buffer
		err := tmplVec.Execute(&buf, vecType)

		if err != nil {
			panic(err)
		}

		writeCode(fmt.Sprintf("gen_vec%d.go", vecType.Len), buf.String())
	}
}

func generateMats() {
	matTypes := []modelMat{
		{
			Len: 2,
		},
		{
			Len: 3,
		},
		{
			Len: 4,
		},
	}

	for _, matType := range matTypes {
		var buf bytes.Buffer
		err := tmplMat.Execute(&buf, matType)

		if err != nil {
			panic(err)
		}

		writeCode(fmt.Sprintf("gen_mat%d.go", matType.Len), buf.String())
	}
}

func writeCode(name string, source string) {
	formatted, err := format.Source([]byte(source))
	if err != nil {
		panic(err)
	}

	_ = os.WriteFile(name, formatted, 0644)
}

type Swizzle struct {
	Name       string
	Components []int
}

func generateSwizzles(n int) []Swizzle {
	var swizzles []Swizzle
	for _, swizzle := range generateAllSwizzles(n, n) {
		if len(swizzle.Components) <= 1 {
			continue
		}

		swizzles = append(swizzles, swizzle)
	}

	return swizzles
}

func generateAllSwizzles(lenVec, n int) []Swizzle {
	if n == 0 {
		return []Swizzle{
			// empty swizzle
			{Components: []int{}},
		}
	}

	swizzles := generateAllSwizzles(lenVec, n-1)

	for _, swizzle := range swizzles {
		if len(swizzle.Components) != n-1 {
			continue
		}

		for idx := range lenVec {
			components := append([]int(nil), swizzle.Components...)

			swizzles = append(swizzles, Swizzle{
				Name:       fmt.Sprintf("%s%c", swizzle.Name, "XYZW"[idx]),
				Components: append(components, idx),
			})
		}
	}

	return swizzles

}

type modelVec struct {
	Len     int
	LenWGPU int
}

func (s modelVec) Swizzles() []Swizzle {
	return generateSwizzles(s.Len)
}

func (s modelVec) Name() string {
	return fmt.Sprintf("Vec%d", s.Len)
}

func (s modelVec) Type() string {
	return s.Name() + "[T]"
}

type modelMat struct {
	Len int
}

func (s modelMat) Name() string {
	return fmt.Sprintf("Mat%d", s.Len)
}

func (s modelMat) Type() string {
	return s.Name() + "[T]"
}

func (s modelMat) ValueCount() int {
	return s.Len * s.Len
}

func (s modelMat) ArrayType() string {
	return fmt.Sprintf("[%d][%d]T", s.Len, s.Len)
}

func (s modelMat) At(name string, x, y int) string {
	var res string = name

	res += fmt.Sprintf("[%d][%d]", y, x)
	if x == y {
		res = fmt.Sprintf("(%s+1)", res)
	} else {
		res = fmt.Sprintf("(%s+0)", res)
	}

	return res
}

var funcs = template.FuncMap{
	"comma": func(idx int) string {
		if idx == 0 {
			return " "
		} else {
			return ","
		}
	},
	"sep": func(idx int, empty, sep string) string {
		if idx == 0 {
			return empty
		} else {
			return sep
		}
	},
	"plus": func(a, b int) int {
		return a + b
	},
	"minus": func(a, b int) int {
		return a - b
	},
	"component": func(idx int) string {
		names := []string{"x", "y", "z", "w"}
		return names[idx]
	},
	"toComponents": func(len int) string {
		return "XYZW"[:len]
	},
}

var tmplVec = template.Must(template.New("").Funcs(funcs).Parse(`
// Code generated by generate.go: DO NOT EDIT.

package glm

import "fmt"
import "math"

// {{.Name}}f is an alias for the float32 variant of {{.Name}} 
type {{.Name}}f = {{.Name}}[float32]

// {{.Name}}u is an alias for the uint32 variant of {{.Name}} 
type {{.Name}}u = {{.Name}}[uint32]

// {{.Name}}uh is an alias for the uint16 variant of {{.Name}} 
type {{.Name}}uh = {{.Name}}[uint16]

// {{.Name}} is a vector of dimension {{.Len}}.
type {{.Name}}[T Numeric] [{{ .Len }}]T

func (lhs {{.Type}}) Dot(rhs {{.Type}}) T {
	return {{ range $idx := .Len }} {{ sep $idx "" "+"}} lhs[{{$idx}}] * rhs[{{$idx}}] {{ end }}
}

func (lhs {{.Type}}) LengthSqr() T {
	return lhs.Dot(lhs)
}

func (lhs {{.Type}}) Length() T {
	return T(math.Sqrt(float64(lhs.Dot(lhs))))
}

func (lhs {{.Type}}) Normalize() {{.Type}} {
	return lhs.Scale(1.0 / lhs.Length())
}

func (lhs {{.Type}}) Scale(s T) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		lhs[{{$idx}}] * s,
		{{- end }}
	}
}

func (lhs {{.Type}}) Reciprocal() {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		1.0 / lhs[{{$idx}}],
		{{- end }}
	}
}

func (lhs {{.Type}}) Add(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		lhs[{{$idx}}] + rhs[{{$idx}}],
		{{- end }}
	}
}

func (lhs {{.Type}}) Sub(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		lhs[{{$idx}}] - rhs[{{$idx}}],
		{{- end }}
	}
}

func (lhs {{.Type}}) Mul(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		lhs[{{$idx}}] * rhs[{{$idx}}],
		{{- end }}
	}
}

func (lhs {{.Type}}) Div(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		lhs[{{$idx}}] / rhs[{{$idx}}],
		{{- end }}
	}
}

func (lhs {{.Type}}) Min(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		min(lhs[{{$idx}}], rhs[{{$idx}}]),
		{{- end }}
	}
}

func (lhs {{.Type}}) Max(rhs {{.Type}}) {{.Type}} {
	return {{.Type}}{
		{{- range $idx := .Len }}
		max(lhs[{{$idx}}], rhs[{{$idx}}]),
		{{- end }}
	}
}

{{ if (lt $.Len 4) }}
	func (lhs {{.Type}}) Extend({{component .Len}} T) Vec{{plus .Len 1}}[T] {
		return Vec{{plus .Len 1}}[T]{
			{{- range $idx := .Len }}
			lhs[{{$idx}}],
			{{- end }}
			{{component .Len}},
		}
}
{{ end  }}

{{ if (gt $.Len 2) }}
	func (lhs {{.Type}}) Truncate() Vec{{minus .Len 1}}[T] {
		return Vec{{minus .Len 1}}[T]{
			{{- range $idx := (minus .Len 1) }}
			lhs[{{$idx}}],
			{{- end }}
		}
	}
{{ end }}

{{ range $swizzle := .Swizzles }}
	// Swizzle{{ $swizzle.Name }} returns a new vector with the components of this
	// vector in the order of {{ $swizzle.Name }}.
	func (lhs {{$.Type}}) Swizzle{{$swizzle.Name}}() Vec{{ $swizzle.Components|len }}[T] {
		return Vec{{ $swizzle.Components|len }}[T]{
			{{- range $idx := $swizzle.Components }}
			lhs[{{$idx}}],
			{{- end }}
		}
	}
{{ end }}

{{ range $len := (plus .Len 1) }}
	{{ if (gt $len 1) }}
	func (lhs {{$.Type}}) {{toComponents $len}}() ({{ range $idx := $len}}{{comma $idx}}{{ component $idx }}{{end}} T) {
		{{- range $idx := $len }}
		{{component $idx}} = lhs[{{$idx}}]
		{{- end }}
		return
	}
	{{ end }}
{{ end }}

func (lhs {{.Type}}) To{{.Name}}f() {{.Name}}f {
	return {{.Name}}f{
		{{- range $idx := .Len }}
		float32(lhs[{{$idx}}]),
		{{- end }}
	}
}

func (lhs {{.Type}}) ToWGPU() [{{.LenWGPU}}]float32 {
	return [{{.LenWGPU}}]float32{
		{{- range $idx := .Len }}
		float32(lhs[{{$idx}}]),
		{{- end }}
	}
}

func (lhs {{.Type}}) String() string {
	return fmt.Sprintf(
		"vec{{.Len}}({{range $idx := .Len}}{{sep $idx "" ", "}}%v{{end}})",
		{{- range $idx := .Len }}
		lhs[{{$idx}}],
		{{- end }}
	)
}

`))

var tmplMat = template.Must(template.New("").Funcs(funcs).Parse(`
// Code generated by generate.go: DO NOT EDIT.

package glm

// {{.Name}}f is an alias for the float32 variant of {{.Name}} 
type {{.Name}}f = {{.Name}}[float32]

// {{.Name}}u is an alias for the uint32 variant of {{.Name}} 
type {{.Name}}u = {{.Name}}[uint32]

// {{.Name}}uh is an alias for the uint16 variant of {{.Name}} 
type {{.Name}}uh = {{.Name}}[uint16]

// {{.Name}} is a {{.Len}}x{{.Len}} matrix.
// The default value is the identity matrix.
type {{.Name}}[T Numeric] struct {
	values {{.ArrayType}}
}

func {{.Name}}Of[T Numeric](values {{.ArrayType}}) {{.Type}} {
	return {{ .Type }}{
		values: {{.ArrayType}}{
		{{- range $y := $.Len }}
			{
			{{- range $x := $.Len }}
				values[{{$y}}][{{$x}}] {{if eq $x $y}}-1{{end}},
			{{- end }}
			},
		{{- end }}
		},
	}
}

func Identity{{.Name}}[T Numeric]() {{.Type}} {
	return {{.Type}}{}
}

func (m {{.Type}}) Mul(o {{.Type}}) {{.Type}} {
	mv := &m.values
	ov := &o.values

	return {{ .Type }}{
		values: {{.ArrayType}}{
		{{- range $y := $.Len }}
			{
			{{ range $x := $.Len }}
				{{- range $i := $.Len -}}
					{{ sep $i " " "+" -}}
					{{ $.At "mv" $x $i }} * {{ $.At "ov" $i $y }}
				{{- end -}} {{ if eq $x $y }} -1 {{ end }},
			{{ end }}
			},
		{{- end }}
		},
	}
}

func (m {{.Type}}) Transpose() {{.Type}} {
	mv := &m.values

	return {{ .Type }}{
		values: {{ .ArrayType }}{
		{{- range $y := $.Len }}
			{
			{{- range $x := $.Len }}
				mv[{{$x}}][{{$y}}],
			{{- end }}
			},
		{{- end }}
		},
	}
}

func (m {{.Type}}) Components() {{.ArrayType}} {
	values := m.values
	{{- range $i := $.Len }}
	values[{{$i}}][{{$i}}] += 1
	{{- end }}
	return values
}

{{ range $y := $.Len }}
{{ range $x := $.Len }}
	func (m {{$.Type}}) m{{$y}}{{$x}}() T {
		return {{ $.At "m.values" $x $y }}
	}
{{ end }}
{{ end }}

`))
